.. ##
.. ## Copyright (c) 2022, Lawrence Livermore National Security, LLC and
.. ## other RADIUSS Project Developers. See the top-level COPYRIGHT file for details.
.. ##
.. ## SPDX-License-Identifier: (MIT)
.. ##

.. _build_and_test-label:


*******************************************
Build and test without breaking your habits
*******************************************

.. image:: images/UberenvWorkflowScript.png
   :scale: 32 %
   :alt: We need the project to be buildable from the CMake cached configuration file. A build script will be required for CI.
   :align: center

The second step in adopting RADIUSS CI infrastructure is to make sure your
project can be built using the configuration file generated by Spack. Other
than that, building and testing your code should follow the usual development
workflow.

Spack is not longer involved at this point. But using the configuration file
will make sure the build uses the Spack installed dependencies and the options
specified by the Spack spec.


==============================================
Using configuration files to build the project
==============================================

The (CMake) configuration files are specific to the desired machine and
toolchain. With CMake, the usage is as follow:

.. code-block:: bash

  $ mkdir build && cd build
  $ cmake -C  <path-to>/<configuration>.cmake ..
  $ cmake --build -j .
  $ ctest --output-on-failure -T test

In the end, this should not be a major change in the developers habit: this is
standard CMake procedure.

.. _write-ci-script:

=======================
Writing a script for CI
=======================

The CI expects a script that:

* is named ``scripts/gitlab/build-and-test``.
* is parametrized by the variable ``SPEC`` which should contain a Spack spec
  with the project name stripped out.
* covers both step 1 (installation of dependencies, configuration file
  generation) and step 2 (build the project from the configuration file, test
  it).

The script should therefore be calleable that way:

.. code-block:: bash

  $ SPEC="%clang@9.0.0 +cuda" scripts/gitlab/build_and_test.sh

.. note::
  Making the CI scripts usable outside CI context is recommended since, by
  definition, it has been vetted. It also ensures that this script is usable in
  interactive mode, making it easier to test. This is why to document it in the
  build part rather than the CI part.

Umpire, RAJA, CHAI, MFEM each have their own script you could easily adapt. All
these projects use Uberenv to drive Spack. Umpire, RAJA and CHAI share the
Spack configuration files in `Radiuss-Spack-Configs`_ in order to keep building
with the same tool-chains.


=========
Debugging
=========

In the workflow described above, there are 4 levels of scripts to control the
build of a package. From the lower to the higher level:

* The *build system* is controlled by the configuration file (generated by Spack
  or not).
* The *Spack package* is controlled by the spec provided and spack configuration.
* *Uberenv* takes a spec and a json configuration file.
* A *build_and_test script* also sometimes called test driver. The one in Umpire
  and RAJA requires a spec and some other control variables.

Now, when it comes to debugging, each level has some requirements to reproduce
a failing build:

* The *build_and_test script* typically runs in CI context. This means that it
  may not be designed to run outside CI. It is better if it does, and we try to
  do that in RADIUSS, but it is not guaranteed. * *Uberenv* is meant to provide
  a turnkey way to install the project and its dependencies. It is usually a
  good way to reproduce a build on the same machine. The CI creates working
  directories in which the uberenv install directory _may_ persist, but it is
  better to reproduce in a local clone.
* Reproducing a build with *Spack* requires a deep knowledge of it. But Uberenv
  helps a lot with that. We advice that you use Uberenv to generate the Spack
  instance. Then, loading the spack instance generated and working with it is
  safe.
* Going down to the *build system* is also doable, especially when using the
  generated configuration files. Once spack has installed the dependencies and
  generated the configuration files, the latter can be used to control the
  build of the code and this should not require using Spack.
